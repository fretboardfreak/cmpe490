The software system for our project is broken into several modules, starting with a main function and branching out into the modules performing various tasks.  The main function will set up interrupts, initialize I/O pins and calls init_motors() which configures the stepper motors.  After this, main() calls start().  Start waits for the start button to be pressed, this will be signaled by an interrupt modifying a semaphore or similar data structure.  At this point, we will be applying preprocessor directives to develop different levels of complexity as our design progresses.  The first step will simply use buttons to manually position the stepper motors and fire the nerf dart.  The second stage will be to take the image from the camera directly beneith the nerf gun, calculate the offset angle to the target, and swing the turret to the desired position.  Once the turret is in place, the user will be free to adjust the firing elevation and fire the dart with the buttons.  Once these two steps have been completed we will implement the fully automatic process.

The following functions form the bulk of the system and perform all the tasks in the process.

The function get_target() is called by start() once a buttons is pressed and manages all the other functions involved in finding the target and firing the dart.  It will follow the process of finding the azimuth, calculating the elevation, aiming the turret, and firing the dart.  The first function called from get_target() is take_picture().  This function will interact with the camera driver to communicate over the UART with the camera and store the received jpeg.  The jpeg is then passed into find_centroid() which uses a point of interest algorithm that returns the average position of the brightest points in the image.  As long as there is only one distinct bright area on the image, this algorithm will point to the rough centre of that area.  The centroid points are used by the functions calc_azimuth() and calc_range(), the latter of which is called by calc_elevation().  Calc_azimuth() uses a model to generate the required angle to face the target from the number of pixels from the centre of the image.  Calc_elevation() will use a lookup table with data gathered experimentally for elevation angles to hit specific distances.  The distance is calculated in calc_range() which uses centroid coordinates from both cameras and a triangulation formula to find the distance to the target.

All the information gathered from the above functions is eventually sent to the set_motor() function which interacts with the stepper motor driver to adjust the positions of the two stepper motors to aim the ALPL.  Once all the calculations have been completed, and the motors are in their desired positions, get_target() will call fire() which will use two calls to set_servo() to move the servo to push in the trigger.  After the dart has been fired, the program will reset the motors to their initial states and return to the loop in start() to await another interrupt.
